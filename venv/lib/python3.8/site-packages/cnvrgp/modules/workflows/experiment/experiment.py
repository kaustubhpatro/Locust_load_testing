import time
from datetime import datetime

from cnvrgp.config import routes
from cnvrgp.modules.base.workflow_instance_base import WorkflowInstanceBase
from cnvrgp.utils.chart_utils import Chart
from cnvrgp.proxy import Proxy, HTTP
from cnvrgp.context import Context, SCOPE
from cnvrgp.utils.json_api_format import JAF
from cnvrgp.utils.url_utils import urljoin
from cnvrgp.utils.env_helper import ENV_KEYS
from cnvrgp.modules.workflows.workflow_utils import WorkflowUtils, WorkflowStatuses


class Experiment(WorkflowInstanceBase):
    available_attributes = {
        "input": str,
        "href": str,
        "remote": str,
        "ma": str,
        "is_running": bool,
        "terminal_url": str,
        "termination_time": datetime,
        **WorkflowInstanceBase.available_attributes
    }

    def __init__(self, context=None, slug=None, attributes=None):
        super().__init__()
        self._context = Context(context=context)

        # Set current context scope to current project
        if slug:
            self._context.set_scope(SCOPE.EXPERIMENT, slug)

        self.scope = self._context.get_scope(SCOPE.EXPERIMENT)

        self._proxy = Proxy(context=self._context)
        self._route = routes.WORKFLOW_BASE.format(
            self.scope["organization"],
            self.scope["project"],
            self.scope["experiment"]
        )
        self._attributes = attributes or {}
        self._type = "Experiment"
        self.slug = self.scope["experiment"]

    def restart(self):
        """
        restarts an experiment
        @return: The restarted experiment object
        """
        return super().start()

    def finish(self, exit_status):
        # TODO: remove after uniting finish and stop in server.
        #  Ask Leah if experiment should have finish as syntax (product wise)
        """
        Finishes the current experiment
        @param exit_status: exit status of the experiment
        @return: The finished experiment
        """
        finish_url = urljoin(self._route, routes.EXPERIMENT_FINISH_SUFFIX)
        attributes = {
            "exit_status": exit_status
        }

        return self._proxy.call_api(
            route=finish_url,
            http_method=HTTP.POST,
            payload=JAF.serialize(type=self._type, attributes=attributes)
        )

    def create_chart(self, chart: Chart):
        """
        Creates a chart for the current experiment
        @param chart: A chart object
        @return: The created chart object
        """
        create_chart_url = urljoin(self._route, routes.EXPERIMENT_CHARTS_SUFFIX)

        # TODO: return value currently not in JAF format. remove after server fixed.
        return self._proxy.call_api(
            route=create_chart_url,
            http_method=HTTP.POST,
            payload=JAF.serialize(type=self._type, attributes=chart.to_dict())
        )

    def as_env(self):
        """
        @return: A dict representing current experiment for env use
        """
        return {
            ENV_KEYS["current_job_id"]: self.slug,
            ENV_KEYS["current_job_type"]: self._type,
            ENV_KEYS["current_project"]: self.scope["project"],
            ENV_KEYS["current_organization"]: self.scope["organization"],
        }

    def pull_artifacts(self, wait_until_success=False, poll_interval=10):
        """
        pulls current experiment's artifacts to the local working dir
        @param wait_until_success: Wait until current experiment is done before pulling artifacts
        @param poll_interval: Is wait_until_success is True, time between status poll loops
        @return: None
        """
        if wait_until_success:
            WorkflowUtils.wait_for_statuses(self, WorkflowStatuses.SUCCESS, poll_interval=poll_interval)

        self._clone_artifact(start_commit=self.start_commit)

    def log_images(self, file_paths):
        """
        Saves the given images to the current experiment as a new commit
        Note that only images that will be saved via this function
        Will show as experiment visuals
        @param file_paths: list of paths of artifacts to save
        @return: None
        """
        commit_msg = "Log Images Commit"
        self.put_files(file_paths, message=commit_msg, job_slug=self.slug, tag_images=True)

    def log_artifacts(self, file_paths):
        """
        Saves the given artifacts to the current experiment as a new commit
        @param file_paths: list of paths of artifacts to save
        @return: None
        """
        commit_msg = "Log Artifacts Commit"
        self.put_files(file_paths, message=commit_msg, job_slug=self.slug)

    def sync_local(self):
        """
        Sync files of current experiment between local folder and remote server
        @return: None
        """
        super().sync_local(job_slug=self.slug)

    def _rerun(self, sync=True, prerun=False, requirements=False):
        """
        Rerun experiment that's currently in debug mode
        @param sync: sync before rerunning
        @param prerun: run prerun.sh script
        @param requirements: install requirements file
        @return: None
        """
        rerun_url = urljoin(self._route, routes.EXPERIMENT_RERUN_SUFFIX)
        attributes = {
            "sync": sync,
            "prerun": prerun,
            "requirements": requirements
        }

        self._proxy.call_api(
            route=rerun_url,
            http_method=HTTP.POST,
            payload=JAF.serialize(type=self._type, attributes=attributes)
        )

    def _wait_until_experiment_finish(self, poll_interval=10):
        """
        Busy waits until current experiment run is done
        @param poll_interval: time between status poll loops
        @return: The status of the experiment when done.
        """
        while self.is_running:
            time.sleep(poll_interval)
            self.reload()
        return self.status


