import os
import requests
import yaml

from cnvrgp.config import error_messages, routes
from cnvrgp.errors import CnvrgError, CnvrgArgumentsError, CnvrgHttpError
from cnvrgp.modules.users.users_client import UsersClient
from cnvrgp.proxy import Proxy, HTTP

CONFIG_VERSION = 2
CONFIG_FILE_NAME = "cnvrgp.config"
LOCAL_CNVRG_PATH = os.path.join(os.getcwd(), ".cnvrgp")
GLOBAL_CNVRG_PATH = os.path.join(os.path.expanduser("~"), ".cnvrgp")  # TODO: might break on windows


class SCOPE:
    PROJECT = {
        "key": "project",
        "dependencies": ["organization", "user"]
    }
    IMAGE = {
        "key": "image",
        "dependencies": ["organization", "user"]
    }
    VOLUME = {
        "key": "volume",
        "dependencies": ["project", "organization", "user"]
    }
    DATASET = {
        "key": "dataset",
        "dependencies": ["organization", "user"]
    }
    COMMIT = {
        "key": "commit",
        "dependencies": ["dataset", "organization", "user"]
    }
    QUERY = {
        "key": "query",
        "dependencies": ["dataset", "organization", "user"]
    }
    RESOURCE = {
        "key": "resource",
        "dependencies": ["organization", "user"]
    }
    TEMPLATE = {
        "key": "template",
        "dependencies": ["resource", "organization", "user"]
    }
    EXPERIMENT = {
        "key": "experiment",
        "dependencies": ["project", "organization", "user"]
    }
    WORKSPACE = {
        "key": "workspace",
        "dependencies": ["project", "organization", "user"]
    }
    WEBAPP = {
        "key": "webapp",
        "dependencies": ["project", "organization", "user"]
    }
    ENDPOINT = {
        "key": "endpoint",
        "dependencies": ["project", "organization", "user"]
    }
    ORGANIZATION = {
        "key": "organization",
        "dependencies": ["user"]
    }

    @classmethod
    def scopes(cls):
        """
        Calculates all of the scopes from the class attributes
        @return: scope list
        """
        scopes = []
        for attr in dir(cls):
            if not callable(getattr(cls, attr)) and not attr.startswith("__"):
                scopes.append(getattr(cls, attr)["key"])
        return scopes


class Context:
    def __init__(self, context=None, domain=None, user=None, password=None, organization=None):
        # Set the credentials variables:
        self.token = None
        self.domain = None
        self.user = None

        # Set scope variables:
        for scope in SCOPE.scopes():
            setattr(self, scope, None)

        # If a context is passed, perform a deep copy and return
        if context:
            self._copy_context(context=context, organization=organization)
            return

        # Cannot pass username/password without a domain+username+password
        if (user or password) and not all([domain, user, password]):
            raise CnvrgError(error_messages.CONTEXT_BAD_ARGUMENTS)

        # If a domain is passed, init a blank Cnvrg client
        if domain:
            self.domain = domain

            # Attempt to authenticate using the credentials if they were passed
            if user:
                self._authenticate(domain, user, password)
        else:
            self._load_credentials()

        # Override organization if it was explicitly passed
        if organization:
            self.organization = organization

        self._ensure_organization_exist(self.organization)

    def get_scope(self, scope):
        """
        Checks if the current context contains the relevant scope
        @param scope: a SCOPE object constant
        @raise CnvrgError: if the context does not contain the required scope dependencies
        @return: scope dictionary
        """

        dependencies_dict = self._check_dependencies(scope)
        cur_scope = getattr(self, scope["key"], None)
        if cur_scope is None:
            error_msg = error_messages.CONTEXT_SCOPE_BAD_SCOPE.format(scope["key"])
            raise CnvrgError(error_msg)

        return {scope["key"]: cur_scope, **dependencies_dict}

    def set_scope(self, scope, slug):
        """
        Checks if the current context contains the relevant scope and sets new scope
        @param scope: a SCOPE object constant
        @param slug: scope object slug
        @raise CnvrgError: if the context does not contain the required scope dependencies
        @return: slug/None
        """
        if scope == SCOPE.ORGANIZATION:
            self._ensure_organization_exist(slug)

        self._check_dependencies(scope)
        setattr(self, scope["key"], slug)

    def save(self, in_working_dir=False):
        """
        Creates a .cnvrg/config file to reuse authentication.
        Config save will only work in organization context, otherwise an error will be raised
        @param in_working_dir: Whether or not create the config in working directory or globally
        @raise CnvrgError: Tried to save without having at least organization context
        @return: Boolean depending if context save was successful
        """
        if in_working_dir:
            config_path = LOCAL_CNVRG_PATH
        else:
            config_path = GLOBAL_CNVRG_PATH

        if not os.path.isdir(config_path):
            os.mkdir(config_path)

        # Will throw a CnvrgError if organization context is not present
        config_data = self._generate_context_dict()
        config_file_path = os.path.join(config_path, CONFIG_FILE_NAME)

        # Will throw an exception if file is readonly or cannot be created
        # TODO: need to handle this case
        with open(config_file_path, 'w') as config:
            yaml.dump(config_data, config)

    def _copy_context(self, context, organization=None):
        """
        Performs a deep copy of the supplied context into the current one
        @param context: The source context
        @param organization: Organization name to override
        @return: None
        """
        self.token = context.token
        self.domain = context.domain
        self.user = context.user

        for scope in SCOPE.scopes():
            target_attr = getattr(context, scope, None)
            setattr(self, scope, target_attr)

        if organization:
            self.organization = organization

    def _check_dependencies(self, scope):
        """
        This function checks that the requested scope has all of its dependencies initialized
        @param scope: The scope const we want to check
        @return: dict of scopes and their slugs
        """
        # Build scope object
        scope_dict = {}
        for dependency in scope["dependencies"]:
            dependency_slug = getattr(self, dependency, None)
            if dependency_slug is None:
                error_msg = error_messages.CONTEXT_SCOPE_BAD_DEPENDENCIES.format(scope["key"], dependency)
                raise CnvrgError(error_msg)
            else:
                scope_dict[dependency] = dependency_slug

        return scope_dict

    def _authenticate(self, domain, user, password):
        """
        Performs authentication against Cnvrg and retrieves the auth token
        @param domain: Cnvrg app domain
        @param user: Email with which the user was registered
        @param password: Password with which the user was registered
        @return: None
        """
        auth = UsersClient(domain=domain)

        # Will raise an exception if login did not succeed
        token, organization = auth.login(user=user, password=password)

        self.token = token
        self.user = user
        self.organization = organization

        # We don't allow users without an organization to use the context
        if organization is None:
            raise CnvrgError(error_messages.USER_NO_ORGANIZATION)

    def _load_credentials(self):
        """
        Attempts to login using either environment variables or the global Cnvrg config file
        @raise: CnvrgError if cannot login using either method
        @return: None
        """
        logged_in = self._load_from_env() or self._load_from_config()
        if not logged_in:
            raise CnvrgError(error_messages.CONTEXT_BAD_ENV_VARIABLES)

    def _load_from_env(self):
        """
        Attempts to find credentials in environment variables
        @return: Boolean
        """
        token = os.environ.get("CNVRG_JWT_TOKEN")
        domain = os.environ.get("CNVRG_URL")
        user = os.environ.get("CNVRG_USER")
        organization = os.environ.get("CNVRG_ORGANIZATION")

        if not all([token, domain, user, organization]):
            return False

        self.token = token
        self.domain = domain
        self.user = user
        self.organization = organization

        # Pod-specific env vars
        # TODO: generalize the env init
        project = os.environ.get("CNVRG_PROJECT")
        job_slug = os.environ.get("CNVRG_JOB_ID")
        job_type = os.environ.get("CNVRG_JOB_TYPE")

        self.project = project
        if job_type is not None:
            setattr(self, job_type.lower(), job_slug)

        return True

    def _load_from_config(self):
        """
        Attempts to find credentials in local/global config file
        @return: Boolean
        """
        local_config_path = os.path.join(LOCAL_CNVRG_PATH, CONFIG_FILE_NAME)
        global_config_path = os.path.join(GLOBAL_CNVRG_PATH, CONFIG_FILE_NAME)

        if os.path.exists(local_config_path):
            config = yaml.safe_load(open(local_config_path, "r"))
        elif os.path.exists(global_config_path):
            config = yaml.safe_load(open(global_config_path, "r"))
        else:
            return False

        # Credential variables
        token = config.get(":token") or config.get("token")
        domain = config.get(":domain") or config.get("domain")
        user = config.get(":user") or config.get("user")

        # Context variables
        organization = config.get(":organization") or config.get("organization")

        if not all([token, domain, user, organization]):
            return False

        self.token = token
        self.domain = domain
        self.user = user
        self.organization = organization

        return True

    def _generate_context_dict(self):
        """
        Generates a context dict to save in a local config file
        @return: dict
        """
        if not all([self.token, self.domain, self.user, self.organization]):
            raise CnvrgError(error_messages.CONTEXT_CANT_SAVE)

        return {
            "token": self.token,
            "domain": self.domain,
            "user": self.user,

            "project": self.project,
            "experiment": self.experiment,
            "organization": self.organization,

            "verify_ssl": False,
            "version": CONFIG_VERSION
        }

    def _ensure_organization_exist(self, name):
        try:
            proxy = Proxy(domain=self.domain, token=self.token)
            organization_route = routes.ORGANIZATION_BASE.format(name)

            proxy.call_api(route=organization_route, http_method=HTTP.GET)

        except CnvrgHttpError as e:
            if e.status_code == requests.codes.not_found:
                raise CnvrgArgumentsError({"organization": error_messages.ORGANIZATION_DOESNT_EXIST})
            else:
                # Don't suppress unexpected exceptions
                raise e
